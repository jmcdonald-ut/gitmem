import type { CommitInfo, EvalVerdict, Classification } from "@/types"
import { CLASSIFICATIONS } from "@/types"

/** System prompt used for all judge evaluation requests. */
export const JUDGE_SYSTEM_PROMPT = `You are a quality evaluator for git commit classifications and summaries. You will be given a commit message, diff, file list, and the classification and summary that were generated by another model. Your job is to evaluate the quality of that classification and summary.

Evaluate three dimensions:
1. Classification correctness — Is the assigned category the best fit for this commit?
2. Summary accuracy — Does the summary accurately describe what actually changed?
3. Summary completeness — Does the summary capture the most important changes?

Respond with valid JSON only, no markdown fences. Use this exact format:
{"classification":{"pass":true/false,"reasoning":"...","suggestedClassification":"only if pass is false"},"accuracy":{"pass":true/false,"reasoning":"..."},"completeness":{"pass":true/false,"reasoning":"..."}}

Valid classifications: ${CLASSIFICATIONS.join(", ")}`

/**
 * Builds the user message sent to the judge for evaluation.
 * @param commit - The commit metadata.
 * @param diff - The unified diff content.
 * @param classification - The original enrichment classification.
 * @param summary - The original enrichment summary.
 * @returns The formatted user message string.
 */
export function buildJudgeUserMessage(
  commit: CommitInfo,
  diff: string,
  classification: string,
  summary: string,
): string {
  return `Commit message: ${commit.message}

Files changed: ${commit.files.map((f) => f.filePath).join(", ")}

Diff:
${diff}

--- Enrichment to evaluate ---
Classification: ${classification}
Summary: ${summary}`
}

/**
 * Parses the judge JSON response into evaluation verdicts,
 * stripping any markdown fences. Defaults to pass on malformed responses.
 * @param text - Raw text response from the judge.
 * @returns The three evaluation verdicts.
 */
export function parseEvalResponse(text: string): {
  classificationVerdict: EvalVerdict
  accuracyVerdict: EvalVerdict
  completenessVerdict: EvalVerdict
} {
  const defaultVerdict: EvalVerdict = {
    pass: true,
    reasoning: "No reasoning provided",
  }

  try {
    const stripped = text
      .replace(/^```(?:json)?\s*\n?/i, "")
      .replace(/\n?```\s*$/, "")
    const parsed = JSON.parse(stripped)

    const classificationVerdict = parseVerdict(parsed.classification)
    if (
      !classificationVerdict.pass &&
      typeof parsed.classification?.suggestedClassification === "string" &&
      CLASSIFICATIONS.includes(parsed.classification.suggestedClassification)
    ) {
      classificationVerdict.suggestedClassification = parsed.classification
        .suggestedClassification as Classification
    }

    return {
      classificationVerdict,
      accuracyVerdict: parseVerdict(parsed.accuracy),
      completenessVerdict: parseVerdict(parsed.completeness),
    }
  } catch {
    return {
      classificationVerdict: { ...defaultVerdict },
      accuracyVerdict: { ...defaultVerdict },
      completenessVerdict: { ...defaultVerdict },
    }
  }
}

function parseVerdict(raw: unknown): EvalVerdict {
  if (raw && typeof raw === "object" && "pass" in raw) {
    const obj = raw as Record<string, unknown>
    return {
      pass: typeof obj.pass === "boolean" ? obj.pass : true,
      reasoning:
        typeof obj.reasoning === "string"
          ? obj.reasoning
          : "No reasoning provided",
    }
  }
  return { pass: true, reasoning: "No reasoning provided" }
}
